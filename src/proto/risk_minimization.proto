package PS;
import "proto/range.proto";
import "proto/evaluation.proto";
import "proto/instance.proto";

message BlockSolverConfig {
  // The minibatch size. If <= 0, then use the whole data
  optional int64 minibatch_size = 1 [default = 0];
  // Divide a feature group into feature_block_ratio x nnz_feature_per_instance
  // blocks
  optional float feature_block_ratio = 2 [default = 0];
  // Use a random order to updating feature block.  Turn it off to elimiate the
  // randomness (often for debuging), but may affects the convergence rate.
  optional bool random_feature_block_order = 3 [default = true];
  // Updating important feature group at the beginning to get a good initial
  // start point.
  repeated int32 prior_fea_group = 14;
  optional int32 num_iter_for_prior_fea_group = 13 [default = 5];
  // Bounded-delay consistency
  optional int32 max_block_delay = 10 [default = 0];
  // max number pass of traing data
  optional int32 max_pass_of_data = 8 [default = 10];
  // convergance critiria. stop if the relative objective <= epsilon
  optional double epsilon = 11 [default = 1e-4];
  // precision of auc, the larger the better
  optional int64 auc_goodness = 12 [default = 100000];
  // features which occurs <= *tail_feature_count* will be filtered before training
  optional int32 tail_feature_count  = 15 [default = 4];
}


message BCDL1LRConfig {
  // Used by the trust region method. All changes of parameters will be bounded
  // by *delta*. *delta* is updated according to the convergence,  whose intial
  // value is *delta_init_value* and maximal value is *delta_max_value*
  optional double delta_init_value = 1 [default = 1];
  optional double delta_max_value = 2 [default = 5];
  // kkt_filter_threshold = max_gradient_violation / num_examples *
  // kkt_filter_threshold_ratio. increasing this number reduces the effect of
  // kkt filter.
  optional double kkt_filter_threshold_ratio = 10 [default = 10];
}

message LossConfig {
  enum Type {
    SQUARE = 1;
    LOGIT = 2;
    HINGE = 3;
    SQUARE_HINGE = 4;
  }
  required Type type = 1;
}

message LearnerConfig {
  enum Type {
    GRADIENT_DESCENT = 1;
    PROXIMAL_GRADIENT = 2;
    LBFGS = 3;
  }
  required Type type = 1;
}

message RiskMinProgress {
  optional double objv = 1;
  optional double relative_objv = 2;
  optional uint64 nnz_w = 5;
  optional double violation = 6;
  optional uint64 nnz_active_set = 7;
  optional double training_auc = 8;
  optional AUCData training_auc_data = 9;

  // performance
  optional double total_time = 10;
  repeated double busy_time = 11;
}

message DataInfo {
  optional InstanceInfo ins_info = 1;
  optional int32 hit_cache = 2;
}

message RiskMinCall {
  enum Command {
    LOAD_DATA = 1;
    PREPROCESS_DATA = 2;
    UPDATE_MODEL = 3;
    EVALUATE_PROGRESS = 4;
    SAVE_MODEL = 5;  // save w
    RECOVER = 6;
    COMPUTE_VALIDATION_AUC = 7;
    // SAVE_AS_DENSE = 7;     // save X * w in a given key range
  }
  required Command cmd = 1;
  optional PbRange key = 2;
  // optional int32 feature_group_id = 3;

  optional double kkt_filter_threshold = 4;
  optional bool kkt_filter_reset = 5;

  // repeated PbRange reduce_range = 6;
  // optional string name = 7;

  repeated int32 fea_grp = 8;
  // repeated int32 w_chl = 9;
}

message AggGradLearnerArg {
  optional double learning_rate = 1;
}
